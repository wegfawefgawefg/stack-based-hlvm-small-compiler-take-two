# Scheme-like Language Compiler Project

## I. Overall Project Goals

1.  **Implement a Compiler:** Develop a compiler for a custom Scheme-like language.
2.  **Python Implementation:** The compiler and initial Virtual Machine (VM) will be written in Python.
3.  **Target Virtual Machine:**
    * **Initial Target:** A simple, custom stack-based Virtual Machine (VM).
    * **Stretch Goal:** Explore targeting LLVM for more optimized code generation in the future.
4.  **Educational:** Understand the principles of compiler construction, language design, and VM implementation.

## II. Language Features (Scheme-like)

The language aims to be a "Scheme" that compiles, incorporating the following features:

1.  **Core Data Types:**
    * **Numbers:**
        * Integers (e.g., `10`, `-5`)
        * Floating-point numbers (e.g., `3.14`, `-0.01`)
    * **Strings:** (e.g., `"hello world"`)
    * **Booleans:** (`#t` and `#f` or similar, handled by VM logic)

2.  **Data Structures:**
    * **Structs/Records:** User-defined composite data types (similar to C structs or Python classes without methods initially).
        * Definition mechanism.
        * Instance creation.
        * Field access (get/set).
    * **Enums (Enumerated Types):** A type that has a fixed set of named constant values.

3.  **Control Flow:**
    * **Conditional Execution:** `if` expressions.
    * **Loops:** Basic looping constructs (e.g., `while`, `loop`, or Scheme's `do`/named `let`).

4.  **Functions & Scoping:**
    * **First-Class Functions:** Functions can be passed as arguments, returned from other functions, and assigned to variables.
    * **Recursion:** Functions can call themselves.
    * **Lexical Scoping:** Variables are resolved based on their textual position in the source code (closures).
    * **Variable Definitions:** `define` or `let` for binding names to values.

5.  **Expressions & Evaluation:**
    * Primarily expression-based.
    * Basic arithmetic and logical operations.

## III. Compiler & VM Stages/Features

1.  **Lexer (Tokenizer):** Converts source code text into a stream of tokens.
2.  **Parser:** Takes the token stream and builds an Abstract Syntax Tree (AST) representing the program's structure.
3.  **Code Generator (Bytecode):** Traverses the AST and emits bytecode instructions for the stack-based VM.
4.  **Stack-Based Virtual Machine (Current Focus):**
    * Executes the generated bytecode.
    * Manages an operand stack.
    * Manages a call stack for function calls.
    * Handles environments for lexical scoping (closure support implemented).
    * Instruction set for arithmetic, logic, variable access, control flow, and function calls.

## IV. Future Considerations / Stretch Goals

* Macros
* Garbage Collection (if heap-allocated objects like strings/structs become complex)
* Standard Library
* Error Reporting (more sophisticated than basic runtime errors)
* LLVM Backend
* Type System (static or dynamic with more robust checking)

This list should help us keep track of what we're building!
