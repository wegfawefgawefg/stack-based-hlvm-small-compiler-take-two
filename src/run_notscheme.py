# run_notscheme.py
# End-to-end pipeline for lexing, parsing, compiling, and running NotScheme code.

from lexer import tokenize, LexerError
from parser import Parser, ParserError
from ast_nodes import ProgramNode
from codegen import CodeGenerator, CodeGenerationError
from vm import VirtualMachine, OpCode

import io
import sys
from typing import Any, Optional, List


class NotSchemeError(Exception):
    """Generic error for issues during the NotScheme pipeline."""

    pass


def compile_notscheme_to_bytecode(source_code: str) -> list:
    """
    Compiles NotScheme source code into bytecode.
    """
    try:
        tokens = tokenize(source_code)
        parser = Parser(tokens)
        ast = parser.parse_program()
        codegen = CodeGenerator()
        bytecode = codegen.generate_program(ast)
        return bytecode
    except LexerError as e:
        raise NotSchemeError(f"Lexer Error: {e}")
    except ParserError as e:
        raise NotSchemeError(f"Parser Error: {e}")
    except CodeGenerationError as e:
        raise NotSchemeError(f"Code Generation Error: {e}")
    except Exception as e:
        raise NotSchemeError(f"Unexpected compilation error: {e}")


def execute_bytecode(bytecode: list, capture_prints=False):
    """
    Executes NotScheme bytecode on the VM.
    Returns the final value on top of the VM stack.
    If capture_prints is True, returns (result, printed_output_string).
    """
    vm = VirtualMachine(bytecode)

    if capture_prints:
        old_stdout = sys.stdout
        sys.stdout = captured_output = io.StringIO()
        try:
            result = vm.run()
            printed_text = captured_output.getvalue()
        finally:
            sys.stdout = old_stdout
        return result, printed_text
    else:
        result = vm.run()
        return result


def run_notscheme_test(
    test_name: str,
    source_code: str,
    expected_value: Any = None,
    expect_error: bool = False,
    expected_prints: Optional[List[Any]] = None,
):  # Changed expected_prints to List[Any]
    """
    Runs a NotScheme test case through the full pipeline.
    expected_prints elements should be the raw values, they will be formatted.
    """
    print(f"\n--- Test: {test_name} ---")
    print("Source:\n" + "-" * 10 + f"\n{source_code}\n" + "-" * 10)

    actual_prints_text = ""
    try:
        bytecode = compile_notscheme_to_bytecode(source_code)
        print("Generated Bytecode:")
        for i, instruction in enumerate(bytecode):
            print(f"  {i:03d}: {instruction}")

        if expected_prints is not None:
            result, actual_prints_text = execute_bytecode(bytecode, capture_prints=True)
            print("Captured Output:")
            if actual_prints_text:
                print(actual_prints_text, end="")
            else:
                print("<no output>")
        else:
            result = execute_bytecode(bytecode)

        if expect_error:
            print(
                f"FAIL: Expected an error, but execution succeeded with result: {result}"
            )
        else:
            if expected_prints is not None:
                # Filter out "Execution halted." and empty lines from actual output
                actual_print_lines = [
                    line
                    for line in actual_prints_text.split("\n")
                    if line.strip() and line.strip() != "Execution halted."
                ]

                # Format expected prints to match VM's "Output: value"
                # Handle Python's True/False/None string representations
                formatted_expected_prints = []
                for p_val in expected_prints:
                    if p_val is True:
                        formatted_expected_prints.append("Output: True")
                    elif p_val is False:
                        formatted_expected_prints.append("Output: False")
                    elif p_val is None:  # For NotScheme 'nil'
                        formatted_expected_prints.append("Output: None")
                    else:  # Strings, numbers
                        formatted_expected_prints.append(f"Output: {p_val}")

                if actual_print_lines == formatted_expected_prints:
                    print(f"Prints: PASS")
                else:
                    print(f"Prints: FAIL")
                    print(f"  Expected prints: {formatted_expected_prints}")
                    print(f"  Actual prints  : {actual_print_lines}")

            if expected_value is not None or not expected_prints:
                if result == expected_value:
                    print(f"Result: PASS (Expected: {expected_value}, Got: {result})")
                else:
                    print(f"Result: FAIL (Expected: {expected_value}, Got: {result})")
            elif expected_prints and expected_value is None and result is not None:
                # This case handles when HALT is expected to make result None after prints
                if result is not None:  # If result is not None when it should be
                    print(
                        f"Result: UNEXPECTED (Expected None after prints and HALT, Got: {result})"
                    )
                else:  # Result is None as expected
                    print(f"Result: PASS (Expected: None, Got: {result})")

    except (NotSchemeError, Exception) as e:
        if expect_error:
            print(f"PASS: Caught expected error: {e}")
        else:
            print(f"FAIL: Unexpected error: {e}")
            # import traceback
            # traceback.print_exc()
    print("-" * 20)


if __name__ == "__main__":
    run_notscheme_test(
        "Static Vars and Simple Math",
        """
        (static a 10)
        (static b (+ a 5)) 
        b 
        """,
        expected_value=15,
    )

    run_notscheme_test(
        "Function Def & Call",
        """
        (fn add (x y) (+ x y))
        (static result (add 10 20))
        result 
        """,
        expected_value=30,
    )

    run_notscheme_test(
        "Struct Def & Instance Field Access",
        """
        (struct Point (x_coord y_coord))
        (static p1 (Point 1 2))
        (get p1 y_coord) 
        """,
        expected_value=2,
    )

    run_notscheme_test(
        "If Expression (True branch)",
        """
        (static x 10)
        (if (> x 5) 100 200) 
        """,
        expected_value=100,
    )

    run_notscheme_test(
        "If Expression (False branch)",
        """
        (static x 3)
        (if (> x 5) 100 200) 
        """,
        expected_value=200,
    )

    run_notscheme_test(
        "Let Expression",
        """
        (fn test_let ()
            (let ((a 10) (b (+ a 5))) 
                (+ a b)))
        (test_let)
        """,
        expected_value=25,
    )

    run_notscheme_test(
        "Lambda Expression & Application",
        """
        (static my_adder ((lambda (val_to_add) (lambda (x) (+ x val_to_add))) 5))
        (my_adder 10)
        """,
        expected_value=15,
    )

    run_notscheme_test(
        "Get/Set Struct Fields (in Fn)",
        """
        (struct Pair (first second)) 
        (fn test_get_set ()
          (let p (Pair 10 20))
          (set p second 30)
          (get p second)
        )
        (test_get_set)
        """,
        expected_value=30,
    )

    run_notscheme_test(
        "While Loop",
        """
        (struct Counter (value current_sum))
        (fn test_while ()
          (let c (Counter 0 0))
          (while (< (get c value) 3)     
            (set c current_sum (+ (get c current_sum) (get c value))) 
            (set c value (+ (get c value) 1))                         
          )
          (get c current_sum) 
        )
        (test_while)
        """,
        expected_value=3,
    )

    run_notscheme_test(
        "Begin Expression",
        """
        (begin 
            (let temp 5) 
            (+ temp 10)) 
        """,
        expected_value=15,
    )

    run_notscheme_test(
        "Print Test",
        """
        (print "Hello")
        (print 123)
        (print #t)
        (print nil)
        (+ 1 1) 
        """,
        expected_value=2,
        expected_prints=[
            "Hello",
            123,
            True,
            None,
        ],  # Use Python equivalents for comparison
    )

    run_notscheme_test(
        "Top-level POP test",
        """
        (fn foo () 10)
        (foo) 
        (static x 5) 
        x
        """,
        expected_value=5,
    )

    print("\n--- All NotScheme end-to-end tests completed ---")
